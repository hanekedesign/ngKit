{"version":3,"sources":["ng://ngkit/config.ts","ng://ngkit/services/event.ts","ng://ngkit/services/storage.ts","ng://ngkit/services/token.ts","ng://ngkit/services/http.ts","ng://ngkit/models/cache-item.ts","ng://ngkit/models/model.ts","ng://ngkit/models/policy.ts","ng://ngkit/models/user.ts","ng://ngkit/services/authorization.ts","ng://ngkit/services/authentication.ts","null","ng://ngkit/services/social-authentication.ts","ng://ngkit/services/cache.ts","ng://ngkit/guards/auth-guard.ts","ng://ngkit/guards/auth-resolve-guard.ts","ng://ngkit/services/http-interceptor.ts","ng://ngkit/services/http-auth-interceptor.ts","ng://ngkit/providers.ts","ng://ngkit/ngkit.module.ts"],"names":["Config","_options","this","options","defaultOptions","setOptions","prototype","getOptions","get","key","override","getItem","split","reduce","o","i","setItem","value","_.set","_.merge","authentication","endpoints","check","forogotPassword","getUser","login","logout","register","resetPassword","socialAuth","method","token","social","facebook","id","version","xfbml","scope","twitter","redirectTo","oauthProxy","authorization","http","baseUrl","headers","storage","name","readAs","storeAs","scheme","cache","expires","debug","Injectable","Inject","args","Event","channel","channels","Subject","setChannels","forEach","broadcast","data","Promise","resolve","next","listen","asObservable","Storage","config","db","localForage.createInstance","set","remove","removeItem","clear","Token","tokenName","_this","reject","_token","then","err","read","response","Http","event","HttpHeaders","setDefaultHeaders","eventListeners","ngOnDestroy","Object","keys","subs","k","unsubscribe","buildParams","params","query_params","HttpParams","sub","subscribe","getUrl","url","startsWith","configHeaders","tokenHeader","delete","CacheItemModel","item","assign","defineProperty","JSON","parse","_value","stringify","_expires","minutes","expiration","Date","setMinutes","getMinutes","getTime","isExpired","Model","attributes","moment","PolicyModel","policy","UserModel","user","can","checkPolicy","cannot","allow","policyName","object","allowed","addPolicy","removePolicy","disallow","identify","role","is","isNot","Authorization","policies","findIndex","objects","push","index","find","indexOf","length","clearPolicies","objectIndexs_1","Authentication","httpService","authUser","timeouts","clearTimeout","force","endpoint","Observable","observer","authenticated","checkResolve","res","setAuthenticated","setUser","error","setTimeout","forgotPassword","post","toPromise","getRedirect","redirect","getToken","getAuthenticated","credentials","onLogin","onLogout","storeToken","resolveUser","unauthenticate","pullRedirect","postRegisterLogin","setRedirect","console","HttpClient","extendStatics","d","b","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__read","n","m","Symbol","iterator","r","e","call","ar","done","SocialAuthentication","_super","log","__extends","__","constructor","create","tslib_1.__extends","handleLoginSuccess","storeSocialCredentials","network","authResponse","accessToken","Cache","retrieveCache","_cache","cacheName","store","defautValue","cacheItem","pull","has","AuthGuard","auth","canActivate","route","state","guard","canActivateChild","AuthResolveGuard","HttpInterceptor","intercept","req","clone","handle","AuthInterceptor","pipe","tap","HttpErrorResponse","status","NGKIT_PROVIDERS","provide","HTTP_INTERCEPTORS","useClass","multi","ngKitModule","forRoot","ngModule","providers","useValue","NgModule","imports","HttpClientModule","__spread","arguments","concat"],"mappings":"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","sourcesContent":["import { Inject, Injectable } from '@angular/core';\nimport * as _ from 'lodash';\n\n@Injectable()\nexport class Config {\n    /**\n     * Default configuration.\n     */\n    static defaultOptions: any = {\n        /**\n         * Authentication settings.\n         */\n        authentication: {\n            /**\n             * Common endpoints for authentication sercice.\n             */\n            endpoints: {\n                check: '',\n                forogotPassword: '',\n                getUser: '',\n                login: '',\n                logout: '',\n                register: '',\n                resetPassword: '',\n                socialAuth: ''\n            },\n            /**\n             * Methods used for authentication.\n             */\n            method: {\n                token: true\n            },\n            /**\n             * Social provider configuration.\n             */\n            social: {\n                facebook: {\n                    id: '',\n                    version: 'v2.6',\n                    xfbml: true,\n                    scope: 'public_profile,email'\n                },\n                twitter: {\n                    id: ''\n                },\n                redirectTo: '',\n                oauthProxy: ''\n            }\n        },\n        /**\n         * Authorization options.\n         */\n        authorization: {},\n        /**\n         * Http options.\n         */\n        http: {\n            /**\n             * Based url for http requests.\n             */\n            baseUrl: '',\n            /**\n             * Default headers for http request.\n             */\n            headers: {}\n        },\n        /**\n         * Storage Options\n         */\n        storage: {\n            name: 'ngkitStorage'\n        },\n        /**\n         * Token options.\n         */\n        token: {\n            /**\n             * Default name of authorization token read from responses.\n             */\n            readAs: 'token',\n            /**\n             * Default name of authorization token that is stored.\n             */\n            storeAs: '_token',\n            /**\n             * Scheme to use in Authorization header along with token.\n             */\n            scheme: 'Bearer'\n        },\n        /**\n         * Cache service options.\n         */\n        cache: {\n            /**\n             * Default expiration time in minutes.\n             */\n            expires: 5\n        },\n        /**\n         * Enable debug mode.\n         */\n        debug: false\n    }\n\n    /**\n     * Config options.\n     */\n    options: any;\n\n    /**\n     * Create a new instance of the service..\n     */\n    constructor(@Inject('ngKitOptions') private _options: any) {\n        this.options = Config.defaultOptions;\n        this.setOptions(this._options);\n    }\n\n    /**\n     * Return the configurable options.\n     */\n    getOptions(): any { return this.options; }\n\n    /**\n     * Get an option by key.\n     *\n     * @param   key\n     * @param   override\n     */\n    get(key: string, override: any = false): any {\n        return Config.getItem(key, override)\n    }\n\n    /**\n     * Static method to get an option by key.\n     *\n     * @param   key\n     * @param   override\n     */\n    static getItem(key: string, override?: any): any {\n        if (override) {\n            return override;\n        }\n\n        if (Config.defaultOptions) {\n            return key.split('.').reduce((o, i) => o[i], Config.defaultOptions);\n        }\n    }\n\n    /**\n     * Set an option by key.\n     *\n     * @param   key\n     * @param  value\n     */\n    setItem(key: string, value: any): any {\n        return _.set(this.options, key, value);\n    }\n\n    /**\n     * Set the configurable options.\n     *\n     * @param  options\n     */\n    setOptions(options: any): Config {\n        this.options = _.merge(this.options, options);\n\n        return this;\n    }\n}\n","import { Observable, Subject } from 'rxjs';\nimport { Injectable } from '@angular/core';\n\n@Injectable()\nexport class Event {\n    /**\n     * Event channels.\n     */\n    static channels: Subject<any>[] = [];\n\n    /**\n     * Get an event listener.\n     *\n     * @param  key\n     */\n    static channel(key: any): Subject<any> {\n        if (typeof Event.channels[key] === 'undefined') {\n            Event.channels[key] = new Subject<any>();\n        }\n\n        return Event.channels[key];\n    }\n\n    /**\n     * Set multiple event channels.\n     *\n     * @param events\n     */\n    setChannels(channels: string[]): void {\n        channels.forEach((channel) => Event.channel(channel));\n    }\n\n    /**\n     * Broadcast an event to a channel.\n     */\n    broadcast(key: string, data = {}): Promise<any> {\n        return Promise.resolve(Event.channel(key).next(data));\n    }\n\n    /**\n     *  Listen on a channel for an event.s\n     *\n     * @param  key\n     */\n    listen(key: string): Observable<any> {\n        return Event.channel(key).asObservable();\n    }\n}\n","import { Injectable } from '@angular/core';\nimport { Config } from '../config';\nimport * as localForage from \"localforage\";\n\nexport interface StorageDriver {\n    /**\n     * The database of the storage provider.\n     */\n    db: any;\n\n    /**\n     * Get an item from storage.\n     *\n     * @param   key\n     */\n    get(key: string): Promise<any>;\n\n    /**\n     * Set an item to storage.\n     *\n     * @param  key\n     * @param  value\n     */\n    set(key: string, value: any): Promise<any>;\n\n    /**\n     * Remove an item from storage.\n     *\n     * @param key\n     */\n    remove(key: string): Promise<any>;\n\n    /**\n     * Clear storage.\n     */\n    clear(): Promise<any>;\n}\n\n@Injectable()\nexport class Storage implements StorageDriver {\n    /**\n     * The database of the storage provider.\n     */\n    db: any;\n\n    /**\n     * Create a new instance of the service.\n     *\n     * @param config\n     */\n    constructor(private config: Config) {\n        this.db = localForage.createInstance({\n            name: this.config.get('storage.name')\n        });\n    }\n\n    /**\n     * Get item from local storage.\n     */\n    get(key: string): Promise<any> {\n        return this.db.getItem(key);\n    }\n\n    /**\n     * Set an item to local storage.\n     *\n     * @param  key\n     * @param  value\n     */\n    set(key: string, value: any): Promise<any> {\n        return this.db.setItem(key, value);\n    }\n\n    /**\n     * Remove an item from local storage.\n     *\n     * @param   key\n     */\n    remove(key: string): Promise<any> {\n        return this.db.removeItem(key);\n    }\n\n    /**\n     * Clear local storage.\n     */\n    clear(): Promise<any> {\n        return this.db.clear();\n    }\n}\n","import { Injectable } from '@angular/core';\nimport { Storage } from './storage';\nimport { Config } from './../config';\n\n@Injectable()\nexport class Token {\n    /**\n     * Name of token stored in local storage.\n     */\n    protected _token: string = '_token';\n\n    /**\n     * Constructor.\n     *\n     * @param  config\n     * @param  storage\n     */\n    constructor(\n        public config: Config,\n        private storage: Storage\n    ) { }\n\n    /**\n     * Get the token from local storage.\n     *\n     * @param  tokenName\n     */\n    get(tokenName?: string): Promise<any> {\n        return new Promise((resolve, reject) => {\n            tokenName = tokenName || this.config.get('token.name', this._token);\n\n            this.storage.get(tokenName).then(token => {\n                resolve(token);\n            }, err => reject(err));\n        });\n    }\n\n    /**\n     * Store the token in local storage.\n     *\n     * @param  token\n     * @param  tokenName\n     */\n    set(token: string, tokenName?: string): Promise<any> {\n        return new Promise((resolve, reject) => {\n            tokenName = tokenName || this.config.get('token.name', this._token);\n\n            if (token) {\n                this.storage.set(tokenName, token).then(() => {\n                    resolve(true);\n                }, () => reject('Error: Could not store token.'));\n            } else {\n                reject('Error: No token provided.');\n            }\n        });\n    }\n\n    /**\n     * Remove token from local storage.\n     *\n     * @param  tokenName\n     */\n    remove(tokenName?: string): boolean {\n        tokenName = tokenName || this.config.get('token.name', this._token);\n\n        this.storage.remove(tokenName);\n\n        return true;\n    }\n\n    /**\n     * Read a token from a response object.\n     *\n     * @param  response\n     */\n    read(response: any = null): string {\n        if (response) {\n            let key = this.config.get('token.readAs');\n\n            return key.split('.').reduce((o: any, i: string) => o[i], response);\n        }\n\n        return null;\n    }\n}\n","import { Injectable, OnDestroy } from '@angular/core';\nimport { Config } from './../config';\nimport { Event } from './event';\nimport { Token } from './token';\nimport { HttpHeaders, HttpParams } from '@angular/common/http';\n\n@Injectable()\nexport class Http implements OnDestroy {\n    /**\n     * Create a new instance of the service.\n     *\n     * @param  config\n     * @param  event\n     * @param  token\n     */\n    constructor(\n        public config: Config,\n        public event: Event,\n        public token: Token\n    ) {\n        this.setDefaultHeaders();\n        this.eventListeners();\n    }\n\n    /**\n     * Assignable base url for http calls.\n     */\n    baseUrl: string = '';\n\n    /**\n     * Headers to be sent with all http calls.\n     */\n    public headers: HttpHeaders = new HttpHeaders();\n\n    /**\n     * The subsciptions of the service.\n     */\n    subs: any = {};\n\n    /**\n     * On service destroy.\n     */\n    ngOnDestroy(): void {\n        Object.keys(this.subs).forEach(k => this.subs[k].unsubscribe());\n    }\n\n    /**\n     * Build url parameters for requests.\n     *\n     * @param  params\n     */\n    buildParams(params: any): HttpParams {\n        var query_params = new HttpParams();\n\n        if (params) {\n            Object.keys(params).forEach((key: any) => {\n                if (params[key]) query_params.set(key, params[key]);\n            });\n        }\n\n        return query_params;\n    }\n\n    /**\n     * Event listeners.\n     */\n    private eventListeners(): void {\n        if (this.event) {\n            let sub = () => this.setDefaultHeaders();\n            this.subs['auth:loggingIn'] = this.event.listen('auth:loggingIn').subscribe(sub);\n            this.subs['auth:loggedOut'] = this.event.listen('auth:loggedOut').subscribe(sub);\n            this.subs['auth:check'] = this.event.listen('auth:check').subscribe(sub);\n        }\n    }\n\n    /**\n     * Get url for http request.\n     *\n     * @param  url\n     */\n    public getUrl(url: string): string {\n        if (url.startsWith('/') || url.startsWith('http')) return url;\n\n        let baseUrl = this.baseUrl || this.config.get('http.baseUrl') || '';\n\n        return (baseUrl) ? baseUrl + '/' + url : url;\n    }\n\n    /**\n     * Set the default headers for http request.\n     */\n    setDefaultHeaders(): void {\n        let configHeaders = (this.config) ? this.config.get('http.headers') : null;\n\n        if (configHeaders) {\n            Object.keys(configHeaders).forEach(key => {\n                this.headers = this.headers.set(key, configHeaders[key]);\n            });\n        }\n\n        this.tokenHeader();\n    }\n\n    /**\n     * Add a token header to the request.\n     */\n    tokenHeader(): Promise<any> {\n        return new Promise((resolve) => {\n            if (this.config && this.config.get('authentication.method.token')) {\n                this.token.get().then(token => {\n                    let scheme = this.config.get('token.scheme');\n                    let value = (scheme) ? `${scheme} ${token}` : token;\n                    this.headers = this.headers.set('Authorization', value);\n                    resolve(token ? true : false);\n                }, () => {\n                    this.headers = this.headers.delete('Authorization');\n                    resolve(false);\n                });\n            }\n        })\n    }\n}\n","/**\n * Model for cache items.\n */\nexport class CacheItemModel {\n    /**\n     * When the cache item expires.\n     */\n    _expires: number;\n\n    /**\n     * The value of the cache item.\n     */\n    _value: any;\n\n    /**\n     * Construcotr.\n     *\n     * @param  item\n     */\n    constructor(item: any) {\n        Object.assign(this, item)\n    }\n\n    /**\n     * Get value accessor parses JSON.\n     */\n    get value(): any {\n        return JSON.parse(this._value);\n    }\n\n    /**\n     * Set the value mutator that stringifies value.\n     *\n     * @param  value\n     */\n    set value(value: any) {\n        this._value = JSON.stringify(value);\n    }\n\n    /**\n     * Get expires accessor.\n     */\n    get expires(): number {\n        return this._expires;\n    }\n\n    /**\n     * Set the expires mutator.\n     *\n     * @param  minutes\n     */\n    set expires(minutes: number) {\n        let expiration = new Date();\n        expiration.setMinutes(expiration.getMinutes() + minutes);\n        this._expires = expiration.getTime();\n    }\n\n    /**\n     * Check if cached item is expired.\n     */\n    isExpired(): boolean {\n        return this.expires <= new Date().getTime();\n    }\n}\n","import * as moment from 'moment';\n\nexport class Model {\n    /**\n     * Create a new instance of the mdoel.\n     *\n     * @param  attributes\n     */\n    constructor(attributes?: any) {\n        if (typeof attributes === 'string') {\n            attributes = JSON.parse(attributes);\n        }\n\n        Object.assign(this, attributes);\n    }\n\n    /**\n     * Moment JS\n     *\n     * @return moment\n     */\n    moment = moment;\n}\n","export class PolicyModel {\n    /**\n     * Name of the policy.\n     */\n    name: string;\n\n    /**\n     * The objects of the defined policy.\n     */\n    objects: any[] = [];\n\n    /**\n     * Constructor.\n     *\n     * @param  policy\n     */\n    constructor(policy: any) {\n        Object.assign(this, policy);\n    }\n}\n","import { Authorization } from '../services/authorization';\n\nexport class UserModel {\n    /**\n     * Create a new instance of the model.\n     *\n     * @param authorization\n     * @param user\n     */\n    constructor(\n        private authorization: Authorization,\n        public user: object\n    ) {\n        Object.assign(this, user);\n    }\n\n    /**\n     * Check if user can perform action based on a policy.\n     *\n     * @param  key\n     * @param  value\n     */\n    can(key: string, value: any): boolean {\n        return this.authorization.checkPolicy(key, value);\n    }\n\n    /**\n     * Check if user cannot perform action based on a policy.\n     *\n     * @param  key\n     * @param  value\n     */\n    cannot(key: string, value: any): boolean {\n        return !this.authorization.checkPolicy(key, value);\n    }\n\n    /**\n     * Allow a user to perform action based on a policy.\n     *\n     * @param  policyName\n     * @param  object\n     * @param  allowed\n     */\n    allow(policyName: string, object: any, allowed: Function | boolean): UserModel {\n        if (typeof allowed === 'function' && allowed()) {\n            this.authorization.addPolicy(policyName, object);\n        } else if (typeof allowed === 'boolean' && allowed) {\n            this.authorization.addPolicy(policyName, object);\n        } else {\n            this.authorization.removePolicy(policyName, object);\n        }\n\n        return this;\n    }\n\n    /**\n     * Don't allow a user to perform action based on a policy.\n     *\n     * @param  policyName\n     * @param  object\n     * @param  allowed\n     */\n    disallow(policyName: string, object: any): UserModel {\n        this.authorization.removePolicy(policyName, object);\n\n        return this;\n    }\n\n    /**\n     * Identify a user with a role.\n     *\n     * @param role\n     */\n    identify(role: string): UserModel {\n        this.authorization.addPolicy('roles', role);\n\n        return this;\n    }\n\n    /**\n     * Check if a user is identified as a role.\n     *\n     * @param  role\n     */\n    is(role: string): boolean {\n        return this.authorization.checkPolicy('roles', role);\n    }\n\n    /**\n     * Check if a user is not identified with a role.\n     *\n     * @param  role\n     */\n    isNot(role: string): boolean {\n        return !this.authorization.checkPolicy('roles', role);\n    }\n}\n","import { Injectable } from '@angular/core';\nimport { PolicyModel } from './../models/index';\n\n@Injectable()\nexport class Authorization {\n    /**\n     * Active Policies\n     */\n    policies: PolicyModel[] = [];\n\n    /**\n     * Constructor.\n     */\n    constructor() { }\n\n    /**\n     *  Add a policy to the service.\n     *\n     * @param  key\n     * @param  value\n     */\n    addPolicy(key: string, value?: any): boolean {\n        if (this.policies.findIndex(policy => policy.name == key) < 0) {\n            let policy = new PolicyModel({ name: key });\n\n            if (value) policy.objects.push(value);\n\n            this.policies.push(policy);\n\n            return true;\n        } else {\n            let index = this.policies.findIndex(policy => policy.name == key);\n\n            if (value && !this.policies[index].objects[value]) {\n                this.policies[index].objects.push(value);\n\n                return true;\n            }\n\n            return false;\n        }\n    }\n\n    /**\n     * Check the given policy.\n     *\n     * @param  name\n     * @param  value\n     */\n    checkPolicy(key: string, value: any = null): boolean {\n        let check = false;\n        let policy = this.policies.find(policy => policy.name === key);\n\n        if (policy) {\n            check = true;\n        }\n\n        if (policy && ((value && policy.objects.indexOf(value) >= 0) ||\n            (!value && !policy.objects.length))) {\n            check = true;\n        } else {\n            check = false;\n        }\n\n        return check;\n    }\n\n    /**\n     * Clear all the policies on the service.\n     */\n    clearPolicies(): void {\n        this.policies = [];\n    }\n\n    /**\n     *  Remove a policy that has already been defined.\n     *\n     * @param  key\n     * @param  value\n     */\n    removePolicy(key: string, value: any): boolean {\n        let policy = this.policies.find(policy => policy.name === key);\n\n        if (policy && policy.objects.indexOf(value) >= 0) {\n            let index = this.policies.findIndex(policy => policy.name === name);\n            let objectIndexs: any[] = [];\n\n            policy.objects.forEach((o, i) => {\n                if (o == value) {\n                    objectIndexs.push(i);\n                }\n            });\n\n            objectIndexs.forEach(index => delete policy.objects[index]);\n\n            this.policies[index] = policy;\n\n            return true;\n        }\n\n        return false;\n    }\n}\n","import { HttpClient } from '@angular/common/http';\nimport { Http } from './http';\nimport { Authorization } from './authorization';\nimport { Injectable, OnDestroy } from '@angular/core';\nimport { UserModel } from '../models/index';\nimport { Config } from './../config';\nimport { Token } from './token';\nimport { Event } from './event';\nimport { Observable, Observer } from 'rxjs';\n\n@Injectable()\nexport class Authentication implements OnDestroy {\n    /**\n     * Create a new instance of the service.\n     *\n     * @param  authorization\n     * @param  config\n     * @param  event\n     * @param  http\n     * @param  httpService\n     * @param  token\n     */\n    constructor(\n        public authorization: Authorization,\n        public config: Config,\n        public event: Event,\n        public http: HttpClient,\n        public httpService: Http,\n        public token: Token\n    ) {\n        this.event.setChannels(this.channels);\n        this.eventListeners();\n    }\n\n    /**\n     * Authorized user.\n     */\n    authUser: any = null;\n\n    /**\n     * State of the user authentication.\n     */\n    authenticated: boolean;\n\n    /**\n     * Event channels.\n     */\n    protected channels: string[] = [\n        'auth:login',\n        'auth:logginIn',\n        'auth:loggedIn',\n        'auth:logout',\n        'auth:loggingOut',\n        'auth:loggedOut',\n        'auth:required',\n        'auth:check',\n        'auth:guarded',\n        'auth:registered',\n    ];\n\n    /**\n     * The redirect data on the service.\n     */\n    private redirect: any = null\n\n    /**\n     * The subsciptions of the service.\n     */\n    subs: any = {};\n\n    /**\n     * The timeouts of the component.\n     */\n    timeouts: any = {};\n\n    /**\n     * On service destroy.\n     */\n    ngOnDestroy(): void {\n        Object.keys(this.subs).forEach(k => this.subs[k].unsubscribe());\n        Object.keys(this.timeouts).forEach(k => clearTimeout(this.timeouts[k]));\n    }\n\n    /**\n     * Check if user is logged in.\n     *\n     * @param  force\n     */\n    check(force: boolean = false): Observable<boolean> {\n        let endpoint = this.config.get('authentication.endpoints.check');\n\n        this.event.broadcast('auth:check');\n\n        return new Observable(observer => {\n            if (this.authenticated === false) {\n                this.checkResolve(observer, false);\n            } else if (this.authenticated === true && !force) {\n                this.event.broadcast('auth:loggedIn', this.user());\n                this.checkResolve(observer, true);\n            } else {\n                this.httpService.tokenHeader().then((token) => {\n                    if (token) {\n                        this.getUser(endpoint).then((res) => {\n                            this.setAuthenticated(true);\n                            this.setUser(res.data || res);\n                            this.event.broadcast('auth:loggedIn', this.user());\n                            this.checkResolve(observer, true);\n                        }, () => {\n                            this.setAuthenticated(false);\n                            this.event.broadcast('auth:required', true);\n                            this.checkResolve(observer, false);\n                        });\n                    } else {\n                        this.setAuthenticated(false);\n                        this.checkResolve(observer, false);\n                    }\n                }, err => observer.error(err));\n            }\n        });\n    }\n\n    /**\n     * Resolve the auth check.\n     *\n     * @param observer\n     * @param authenticated\n     */\n    checkResolve(observer: Observer<boolean>, authenticated: boolean): void {\n        this.event.broadcast('auth:check', authenticated).then(() => {\n            this.timeouts['checkResolve'] = setTimeout(() => {\n                observer.next(authenticated);\n            }, 100);\n        });\n    }\n\n    /**\n     * The service event listeners.\n     */\n    eventListeners(): void {\n        this.subs['auth:loggedIn'] = this.event.listen('auth:loggedIn').subscribe((user) => {\n            this.setAuthenticated(true);\n            this.setUser(user);\n        });\n    }\n\n    /**\n     * Send a forgot password request.\n     *\n     * @param  credentials\n     * @param  endpoint\n     * @param  headers\n     */\n    forgotPassword(data: any, endpoint: string = '', headers = {}): Promise<any> {\n        endpoint = this.config.get(\n            'authentication.endpoints.forgotPassword', endpoint\n        );\n\n        return new Promise((resolve, reject) => {\n            return this.http.post(endpoint, data, headers).toPromise()\n                .then(res => resolve(res), error => reject(error));\n        });\n    }\n\n    /**\n     * Returns the redirect data.\n     */\n    getRedirect(): any {\n        return this.redirect;\n    }\n\n    /**\n     * Get the authentication token.\n     */\n    getToken(): Promise<any> {\n        return new Promise((resolve, reject) => {\n            this.token.get().then(token => resolve(token), err => reject(err));\n        });\n    }\n\n    /**\n     * Get the current authenticated user.\n     *\n     * @param  endpoint\n     */\n    getUser(endpoint: string = ''): Promise<any> {\n        endpoint = this.config.get('authentication.endpoints.getUser', endpoint);\n\n        return this.http.get(endpoint).toPromise();\n    }\n\n    /**\n     * Get the value authenticated value.\n     */\n    getAuthenticated(): boolean {\n        return this.authenticated;\n    }\n\n    /**\n     * Set if authenticated value.\n     */\n    setAuthenticated(value: boolean): boolean {\n        return this.authenticated = value;\n    }\n\n    /**\n     * Send a login request.\n     *\n     * @param  credentials\n     * @param  endpoint\n     * @param  headers\n     */\n    login(credentials: any, endpoint: string = '', headers = {}): Promise<any> {\n        endpoint = this.config.get('authentication.endpoints.login', endpoint);\n\n        return new Promise((resolve, reject) => {\n            this.http.post(endpoint, credentials, headers).toPromise()\n                .then(res => {\n                    this.onLogin(res).then(() => resolve(res), error => reject(error));\n                }, error => reject(error));\n        });\n    }\n\n    /**\n     * Send a request to log the authenticated user out.\n     */\n    logout(endpoint: string = '', headers = {}): Promise<any> {\n        return new Promise((resolve, reject) => {\n            this.event.broadcast('auth:loggingOut').then(() => {\n                endpoint = this.config.get('authentication.endpoints.logout', endpoint);\n\n                if (endpoint) {\n                    this.http.post(endpoint, {}, headers).toPromise().then(res => {\n                        this.onLogout();\n                        resolve(res)\n                    }, error => reject(error));\n                } else {\n                    this.onLogout();\n                    resolve();\n                }\n            });\n        });\n    }\n\n    /**\n     * Actions to perform on login.\n     *\n     * @param  res\n     */\n    onLogin(res: object): Promise<any> {\n        return new Promise((resolve, reject) => {\n            this.storeToken(res).then(() => {\n                this.event.broadcast('auth:loggingIn', res).then(() => {\n                    this.resolveUser().then(() => resolve(), err => reject(err));\n                }, err => reject(err));\n            }, err => reject(err));\n        });\n    }\n\n    /**\n     * Actions to perform on logout.\n     */\n    onLogout(): void {\n        this.unauthenticate();\n        this.event.broadcast('auth:loggedOut');\n    }\n\n    /**\n     * Returns and clears the redirect data.\n     */\n    pullRedirect(): any {\n        let redirect = this.redirect;\n\n        this.redirect = null;\n\n        return redirect;\n    }\n\n    /**\n     * Send a register request.\n     *\n     * @param  data\n     * @param   endpoint\n     * @param  headers\n     * @param postRegisterLogin\n     */\n    register(data: object, endpoint: string = '', headers = {}, postRegisterLogin: boolean = false): Promise<any> {\n        endpoint = this.config.get('authentication.endpoints.register', endpoint);\n        return new Promise((resolve, reject) => {\n            this.http.post(endpoint, data, headers).toPromise().then(res => {\n                if (postRegisterLogin) {\n                    this.onLogin(res).then(() => {\n                        resolve(res);\n\n                        this.event.broadcast('auth:registered', res);\n                    }, error => reject(error));\n                } else {\n                    this.event.broadcast('auth:registered', res);\n                }\n            }, error => reject(error));;\n        });\n    }\n\n    /**\n     * Send a reset password request.\n     *\n     * @param   credentials\n     * @param   endpoint\n     * @param  headers\n     */\n    resetPassword(data: any, endpoint: string = '', headers = {}): Promise<any> {\n        endpoint = this.config.get(\n            'authentication.endpoints.resetPassword', endpoint\n        );\n\n        return new Promise((resolve, reject) => {\n            this.http.post(endpoint, data, headers).toPromise().then(res => {\n                this.onLogin(res).then(() => resolve(res))\n            }, error => reject(error));\n        });\n    }\n\n    /**\n     * Resolve the authenticated user.\n     */\n    resolveUser(): Promise<any> {\n        return new Promise((resolve, reject) => {\n            this.timeouts['resolveUser'] = setTimeout(() => {\n                this.getUser().then((user) => {\n                    this.setAuthenticated(true);\n\n                    this.setUser(user.data || user).then((user) => {\n                        this.event.broadcast('auth:loggedIn', user);\n\n                        resolve();\n                    }, error => reject(error));\n                }, error => reject(error));\n            }, 250);\n        });\n    }\n\n    /**\n     * Set the redirect data.\n     */\n    setRedirect(value: any): any {\n        return this.redirect = value;\n    }\n\n    /**\n     * Set the current authenticated user.\n     *\n     * @param  user\n     */\n    setUser(user: object): Promise<any> {\n        if (user) {\n            user = new UserModel(this.authorization, user);\n        }\n\n        return new Promise((resolve) => resolve(this.authUser = user));\n    }\n\n    /**\n     * Store aut token and broadcast an event.\n     *\n     * @param  res\n     */\n    storeToken(res: any): Promise<any> {\n        return new Promise((resolve) => {\n            this.token.set(this.token.read(res)).then(() => {\n                resolve(res);\n            }, error => console.error(error));\n        });\n    }\n\n    /**\n     * Unauthenticate the current user.\n     */\n    unauthenticate(): void {\n        this.token.remove();\n        this.setAuthenticated(false);\n        this.setUser(null);\n        this.authorization.clearPolicies();\n    }\n\n    /**\n     * Get the current authenticated user.\n     */\n    user = (): any => this.authUser;\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { Authentication } from './authentication';\nimport { Authorization } from './authorization';\nimport { Injectable } from '@angular/core';\nimport { Config } from './../config';\nimport { HttpClient } from '@angular/common/http';\nimport { Http } from './http';\nimport { Token } from './token';\nimport { Event } from './event';\n\n@Injectable()\nexport class SocialAuthentication extends Authentication {\n    /**\n     * Constructor.\n     */\n    constructor(\n        public authorization: Authorization,\n        public config: Config,\n        public event: Event,\n        public http: HttpClient,\n        public httpService: Http,\n        public token: Token\n    ) {\n        super(authorization, config, event, http, httpService, token);\n\n        //\n    }\n\n    /**\n     * Login with a social provider.\n     */\n    // login(provider: string, options?: any): Promise<any> {\n    //     return new Promise(() => {\n    //         // this.handleLoginSuccess(res).then((res) => {\n    //         //     this.onLogin(res).then(() => resolve(res));\n    //         // }, (error) => reject(this.handleLoginError(error)))\n    //     });\n    // }\n\n    /**\n     * Handle succesful Facebook login.\n     *\n     * @param  res\n     */\n    handleLoginSuccess(res: object): Promise<any> {\n        return new Promise((resolve, reject) => {\n            this.storeSocialCredentials(res);\n\n            this.http.post(\n                this.config.get('authentication.endpoints.socialAuth'),\n                res\n            ).subscribe(res => {\n                this.onLogin(res).then(() => {\n                    resolve(res);\n                }, error => reject(error));\n            }, error => reject(error));\n        });\n    }\n\n    /**\n     * Handle errors on facebook login.\n     *\n     * @param  error\n     */\n    handleLoginError = (error: object) => console.log(error);\n\n    /**\n     * Store social auth crednetials.\n     *\n     * @param  res\n     */\n    storeSocialCredentials(res: any): void {\n        if (res.network == 'facebook') {\n            this.token.set(\n                res.authResponse.accessToken,\n                'facebook_access_token'\n            );\n        }\n    }\n}\n","import { Injectable, OnDestroy } from '@angular/core';\nimport { CacheItemModel } from '../models/index';\nimport { Storage } from './storage';\nimport { Config } from './../config';\nimport { Event } from './event';\n\ninterface CacheInterface {\n    [key: string]: CacheItemModel;\n}\n\n@Injectable()\nexport class Cache implements OnDestroy {\n    /**\n     * The name of the cache instance.\n     */\n    cacheName: string = 'ngkit_cache';\n\n    /**\n     * In memory collection of cache.\n     */\n    private _cache: CacheInterface = {};\n\n    /**\n     * Constructor.\n     */\n    constructor(\n        private config: Config,\n        private event: Event,\n        private storage: Storage\n    ) {\n        this.retrieveCache();\n\n        this.subs['auth:loggedOut'] = this.event.listen('auth:loggedOut')\n            .subscribe(() => {\n                this._cache = {};\n                this.clear();\n            });\n    }\n\n    /**\n     * The subsciptions of the service.\n     */\n    subs: any = {};\n\n    /**\n     * On service destroy.\n     */\n    ngOnDestroy(): void {\n        Object.keys(this.subs).forEach(k => this.subs[k].unsubscribe());\n    }\n\n    /**\n     * Retrieve the stored cache.\n     */\n    protected retrieveCache(): Promise<any> {\n        return new Promise((resolve, reject) => {\n            this.storage.get(this.cacheName).then(cache => {\n                if (cache) {\n                    Object.keys(cache).forEach((item) => {\n                        cache[item] = new CacheItemModel(cache[item])\n                    });\n\n                    this.cache = cache;\n                } else {\n                    this.cache = this.store();\n                }\n\n                resolve(this.cache);\n            }, err => reject(err));\n        });\n    }\n\n    /**\n     * Save the cache to storage.\n     *\n     * @param  key\n     * @param  value\n     */\n    store(): any {\n        this.storage.set(this.cacheName, this._cache);\n\n        return this._cache;\n    }\n\n    /**\n     * Accessor to the in memeory cache.\n     */\n    get cache(): any {\n        return this._cache;\n    }\n\n    /**\n     * Mutator to the in memeory cache.\n     *\n     */\n    set cache(value) {\n        this._cache = value;\n    }\n\n    /**\n     * Get an item from cache.\n     *\n     * @param   key\n     * @param  defautValue\n     */\n    get(key: string, defautValue: any = null): any {\n        if (this.cache[key] && !this.cache[key].isExpired()) {\n            return this.cache[key].value;\n        } else if (defautValue) {\n            return defautValue;\n        } else {\n            this.remove(key);\n\n            return null;\n        }\n    }\n\n    /**\n     * Set an item to cache.\n     *\n     * @param  key\n     * @param  value\n     * @param  expires\n     */\n    set(\n        key: string,\n        value: any,\n        expires: number = this.config.get('cache.expires')\n    ): void {\n        let cacheItem = new CacheItemModel({ value: value, expires: expires });\n\n        this._cache[key] = cacheItem;\n\n        this.store();\n    }\n\n    /**\n     * Remove an item from cache.\n     *\n     * @param key\n     */\n    remove(key: string): void {\n        delete this.cache[key];\n        this.store();\n    }\n\n    /**\n     * Clear the cache.\n     */\n    clear(): void {\n        this.storage.remove(this.cacheName);\n    }\n\n    /**\n     * Get an item from cache and remove it.\n     *\n     * @param  key\n     */\n    pull(key: string): any {\n        let value = this.get(key);\n        this.remove(key);\n\n        return value;\n    }\n\n    /**\n     * Check if cache has an item.\n     *\n     * @param  key\n     */\n    has(key: string): boolean {\n        return this.get(key) !== null ? true : false;\n    }\n}\n","import { Injectable, OnDestroy } from '@angular/core';\nimport {\n    ActivatedRouteSnapshot, CanActivate, CanActivateChild, RouterStateSnapshot\n} from '@angular/router';\nimport { Authentication } from './../services/authentication';\nimport { Event } from './../services/event';\n\n@Injectable()\nexport class AuthGuard implements CanActivate, CanActivateChild, OnDestroy {\n    /**\n     * Create a new instance.\n     *\n     * @param  auth\n     * @param  event\n     */\n    constructor(\n        public auth: Authentication,\n        public event: Event\n    ) { }\n\n    /**\n     * The subsciptions of the service.\n     */\n    subs: any = {};\n\n    /**\n     * On service destroy.\n     */\n    ngOnDestroy(): void {\n        Object.keys(this.subs).forEach(k => this.subs[k].unsubscribe());\n    }\n\n    /**\n     * Determine if the user can activate a route.\n     *\n     * @param route\n     * @param state\n     */\n    canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Promise<boolean> {\n        return this.guard(route, state);\n    }\n\n    /**\n     * Determine if the user can activate children of a route.\n     *\n     * @param  route\n     * @param  state     *\n     */\n    canActivateChild(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Promise<boolean> {\n        return this.guard(route, state);\n    }\n\n    /**\n     * The method to apply to guard.\n     *\n     * @param route\n     * @param state\n     */\n    guard(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Promise<boolean> {\n        route;\n\n        return new Promise((resolve) => {\n            if (this.auth.user()) {\n                resolve(true);\n            } else {\n                this.subs['auth:check'] = this.auth.check().subscribe(check => {\n                    if (check) {\n                        resolve(true);\n                    } else {\n                        this.event.broadcast('auth:modal');\n                        this.auth.setRedirect(state.url);\n                        resolve(false);\n                    }\n                });\n            }\n        });\n    }\n}\n","import { Injectable, OnDestroy } from '@angular/core';\nimport { CanActivate, CanActivateChild } from '@angular/router';\nimport { Authentication } from './../services/authentication';\nimport { Event } from './../services/event';\n\n@Injectable()\nexport class AuthResolveGuard implements CanActivate, CanActivateChild, OnDestroy {\n    /**\n     * Create a new instance.\n     *\n     * @param  auth\n     * @param  event\n     */\n    constructor(\n        public auth: Authentication,\n        public event: Event\n    ) { }\n\n    /**\n     * The subsciptions of the service.\n     */\n    subs: any = {};\n\n    /**\n     * On service destroy.\n     */\n    ngOnDestroy(): void {\n        Object.keys(this.subs).forEach(k => this.subs[k].unsubscribe());\n    }\n\n    /**\n     * Determine if the user can activate a route.\n     */\n    canActivate(): Promise<boolean> {\n        return this.guard();\n    }\n\n    /**\n     * Determine if the user can activate children of a route.\n     */\n    canActivateChild(): Promise<boolean> {\n        return this.guard();\n    }\n\n    /**\n     * The method to apply to guard.\n     */\n    guard(): Promise<boolean> {\n        return new Promise((resolve) => {\n            if (this.auth.user()) {\n                resolve(true);\n            } else {\n                this.subs['auth:check'] = this.auth.check().subscribe(() => {\n                    resolve(true);\n                });\n            }\n        });\n    }\n}\n","import { Injectable } from '@angular/core';\nimport { Http } from './http';\nimport {\n    HttpEvent, HttpHandler, HttpInterceptor as Interceptor, HttpRequest\n} from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\n@Injectable()\nexport class HttpInterceptor implements Interceptor {\n    /**\n     * Create a new instance of the interceptor.\n     *\n     * @param  http\n     */\n    constructor(\n        public http: Http\n    ) { }\n\n    /**\n     * Intercept the http request.\n     *\n     * @param  req\n     * @param  next\n     */\n    intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n        req = req.clone({\n            headers: this.http.headers,\n            url: this.http.getUrl(req.url)\n        });\n\n        return next.handle(req);\n    }\n}\n","import { Injectable } from '@angular/core';\nimport { Http } from './http';\nimport { Event } from './event';\nimport {\n    HttpEvent, HttpInterceptor, HttpHandler, HttpRequest, HttpErrorResponse\n} from '@angular/common/http';\nimport { Observable } from 'rxjs';\nimport { tap } from 'rxjs/operators';\n\n@Injectable()\nexport class AuthInterceptor implements HttpInterceptor {\n    /**\n     * Create a new instance of the interceptor.\n     *\n     * @param  http\n     * @param  event\n     */\n    constructor(\n        public http: Http,\n        public event: Event,\n    ) { }\n\n    /**\n     * Intercept the http request.\n     *\n     * @param  req\n     * @param  next\n     */\n    intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n        return next.handle(req).pipe(tap(() => { }, (error: any) => {\n            if (error instanceof HttpErrorResponse) {\n                if (error.status === 401) {\n                    this.event.broadcast('auth:required', error);\n                }\n            }\n        }));\n    }\n}\n","import { Config } from './config';\nimport {\n    Authentication, Authorization, Event, Http, SocialAuthentication,\n    Storage, Token, Cache\n} from './services/index';\nimport { AuthGuard, AuthResolveGuard } from './guards/index';\nimport { HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { HttpInterceptor } from './services/http-interceptor';\nimport { AuthInterceptor } from './services/http-auth-interceptor';\n\n/**\n * ngKit Services.\n */\nexport const NGKIT_PROVIDERS: any[] = [\n    Authentication,\n    AuthGuard,\n    AuthResolveGuard,\n    SocialAuthentication,\n    Authorization,\n    Config,\n    Storage,\n    Cache,\n    Event,\n    Http,\n    Token,\n    {\n        provide: HTTP_INTERCEPTORS,\n        useClass: HttpInterceptor,\n        multi: true\n    },\n    {\n        provide: HTTP_INTERCEPTORS,\n        useClass: AuthInterceptor,\n        multi: true\n    }\n];\n","import { NgModule, ModuleWithProviders } from '@angular/core';\nimport { HttpClientModule } from '@angular/common/http';\nimport { NGKIT_PROVIDERS } from './providers';\n\n@NgModule({\n    imports: [HttpClientModule],\n    providers: [\n        ...NGKIT_PROVIDERS,\n    ]\n})\nexport class ngKitModule {\n    /**\n     * ngKit module initializer.\n     *\n     * @param  options\n     */\n    static forRoot(options: any): ModuleWithProviders {\n        return {\n            ngModule: ngKitModule,\n            providers: [\n                { provide: 'ngKitOptions', useValue: options },\n            ]\n        }\n    }\n}\n"]}